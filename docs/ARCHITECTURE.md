# üèóÔ∏è Application Architecture

This document outlines the architecture of the AI-Powered Portfolio. The current implementation is a **client-side, single-page application (SPA)** that interacts with the Google Gemini API via a secure Cloudflare Worker proxy.

## Diagram

The diagram below is an inline Mermaid flowchart so GitHub renders it natively. An SVG fallback (`Architecturemd.svg`) is kept in the repo for tools that prefer a static image.

```mermaid
flowchart LR
  %% Nodes
  subgraph Browser [Browser - Vite]
    A[Vite SPA]
  end

  subgraph Cloudflare [Cloudflare]
    B[Worker]
    C[KV RATE_LIMIT_KV]
    G[Guardrails]
    T[Tools (projectSearch, displayContactForm)]
    E[KV PROJECT_EMBEDDINGS_KV]
  end

  subgraph GoogleCloud [Google Cloud]
    D[Gemini API]
  end

  %% Connections
  A -- "POST /chat (prompt, history)" --> B
  A -- "POST /api/generateEmbedding" --> B
  B -->|Enforce Rate Limits| C
  B -->|Apply Guardrails| G
  G -->|If safe, proceed| B
  B -->|generateContent (with tools, history)| D
  D -->|response (text/tool_call)| B
  B -->|Execute Tool (e.g., projectSearch)| T
  T -->|Tool Output (projects, notice)| B
  B -->|Cache Query Embedding| E
  E -->|Retrieve Project Embeddings| T
  B -->|Streaming SSE (text/tool_response)| A

  %% Styling
  classDef browser fill:#E8F6FF;stroke:#1E90FF;stroke-width:1.5px;color:#03396c;
  classDef cloud fill:#E8FFF2;stroke:#05A678;stroke-width:1.5px;color:#064a33;
  classDef kv fill:#FFF8E8;stroke:#FF9F1C;stroke-width:1px;color:#7a4a00;
  classDef google fill:#FFF4E6;stroke:#FF8C42;stroke-width:1.5px;color:#663300;
  classDef guardrails fill:#FFDDC1;stroke:#FF9933;stroke-width:1.5px;color:#8B4513;
  classDef tools fill:#E0E0FF;stroke:#8A2BE2;stroke-width:1.5px;color:#4B0082;

  class A browser;
  class B cloud;
  class C kv;
  class D google;
  class G guardrails;
  class T tools;
  class E kv;

  linkStyle default stroke:#9aaed8;stroke-width:1px;
```

If you prefer a static image, the repository also includes `Architecturemd.svg` (kept for compatibility with tools that don't render Mermaid).

## Layers

### üé® Presentation Layer (UI)

- **Technologies:** Vanilla TypeScript, HTML, CSS.
  - **HTML Templating:** HTML structures are created using JavaScript template literals within `.ts` files for dynamic content.
- **Responsibilities:** Renders the main portfolio page, including the header, hero section, and project cards. It also provides the user interface for the chatbot, including the chat window, message history, and input form. All UI manipulation is handled directly via the DOM.

### üß† Application Logic Layer (Client-Side)

- **Technologies:** TypeScript.
- **Responsibilities:** This is the core of the application, running entirely in the user's browser.
  - **State Management:** Manages the application state, such as the conversation history.
  - **AI Integration:** Handles communication with the Cloudflare Worker, which securely calls the Google Gemini API and orchestrates tool calls. It processes streaming Server-Sent Events (SSE) from the worker, which can contain both AI text responses and signals for frontend actions (e.g., displaying a contact form). It now sends the full conversation history with each request to the worker, ensuring the model maintains context.
  - **Orchestration Logic:** The client-side logic no longer interprets user intent for tool orchestration. Instead, it sends user prompts to the worker, which then handles tool selection and execution via the LLM.
  - **Data Persistence:** Uses the browser's `sessionStorage` to save and load the chat history, allowing conversations to persist for the duration of the browser tab session.

### üíæ Data Layer

- **Project Data:** Project information is stored in `frontend/projects.ts`, separating it from the UI logic. This data is sent with each chat request to the worker.
- **Conversation History:** Stored in a JavaScript array in memory during the session and persisted to `sessionStorage`. The full conversation history is now sent with each request to the worker to maintain context for the Gemini model.
- **Vector Embeddings:** Project embeddings for semantic search are generated by the Cloudflare Worker (via the `/api/generateEmbedding` endpoint) and cached in `PROJECT_EMBEDDINGS_KV` for query embeddings and in frontend memory (`projectEmbeddings`) on application load for project embeddings.

### ‚òÅÔ∏è Infrastructure & Deployment

- **Technologies:** Docker, Nginx, GitHub Pages, Cloudflare Workers.
- **Responsibilities:**
  - **Docker:** The application includes a multi-stage `Dockerfile` for containerization. This creates a production-ready image by building the static assets and serving them from a lightweight Nginx container. This ensures a small, secure, and efficient deployment.
  - **GitHub Pages:** The application is configured for automated deployment to GitHub Pages via GitHub Actions.
  - **Cloudflare Workers:** The AI backend, responsible for securely interacting with the Gemini API, is deployed as a Cloudflare Worker. It includes:
    - **Tool Orchestration:** Receives tool calls from the Gemini model, executes the corresponding logic (e.g., `projectSearch`, `displayContactForm`), and manages their output. It now correctly handles `functionResponse` parts in the conversation history.
    - **Streaming Responses (SSE):** Streams AI text responses and tool execution results back to the frontend as Server-Sent Events.
    - **Rate Limiting:** An in-memory mechanism to prevent API abuse by limiting requests from a single IP address.
    - **Guardrails:** Logic to block requests containing sensitive patterns, enhancing security and preventing injection attacks. The `TRIPWIRE` regex has been adjusted to prevent false positives.
    - **Embedding Generation:** Provides an `/api/generateEmbedding` endpoint to create vector embeddings for text using the Gemini API, supporting semantic search within the `projectSearch` tool. It now gracefully handles API quota errors and caches query embeddings in KV.

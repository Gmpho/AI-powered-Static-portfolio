INDEX.TSX but we can use the same logic with index.ts file if issues come up use find a way to make this work well here is an example code below


import { initializeChatbot } from "./chatbot";

// --- Type Definitions ---
export interface Project {
  title: string;
  description: string;
  tags: string[];
  url: string;
}

export interface ProjectMetadata {
    name: string;
    description: string;
    url: string;
    tags: string[];
}

/**
 * The hardcoded data source for projects. In a real-world scenario, this would
 * live in a database or a CMS and be fetched by the MCP server tool.
 * @type {Array<Project>}
 */
const projects: Project[] = [
  {
    title: "AI Resume Analyzer",
    description:
      "Upload a PDF resume and receive improvement suggestions based on common best practices.",
    tags: ["TypeScript", "pdf.js", "regex"],
    url: "https://github.com/example/resume-analyzer",
  },
  {
    title: "AI-Powered Portfolio",
    description:
      "A portfolio website with a TypeScript-powered AI chatbot to answer questions about my work.",
    tags: ["TypeScript", "Gemini API", "UI/UX"],
    url: "https://github.com/example/ai-portfolio",
  },
  {
    title: "E-commerce Platform",
    description:
      "A full-stack e-commerce site with features like product search, cart management, and secure payments.",
    tags: ["React", "Node.js", "PostgreSQL", "Stripe"],
    url: "https://github.com/example/ecommerce-platform",
  },
];


// --- DOM Element References ---
const projectsContainer = document.querySelector(".projects");
const themeToggleBtn = document.getElementById('theme-toggle');

/**
 * Simulates the 'projectMetadata' MCP tool. This function is the single source
 * of truth for project data in the application.
 * @returns {Promise<{ projects: ProjectMetadata[] }>} A list of projects conforming to the tool's output schema.
 */
async function projectMetadataTool(): Promise<{ projects: ProjectMetadata[] }> {
    // In a real app, this would be a fetch call to the MCP server.
    // For this simulation, we resolve with the hardcoded data, mapping field names.
    return Promise.resolve({
        projects: projects.map(p => ({
            name: p.title,
            description: p.description,
            url: p.url,
            tags: p.tags,
        }))
    });
}


/**
 * Searches for the best project match using simple keyword scoring.
 * This replaces the more complex semantic search for a client-side deployment.
 * @param {string} query The user's search query text.
 * @param {ProjectMetadata[]} projectsToSearch The list of projects to search through.
 * @returns {ProjectMetadata | null} The project with the highest keyword score.
 */
function findBestProjectMatchByKeywords(query: string, projectsToSearch: ProjectMetadata[]): ProjectMetadata | null {
    const queryWords = query.toLowerCase().split(/\s+/).filter(w => w.length > 2);
    if (queryWords.length === 0) return null;

    let bestMatch: ProjectMetadata | null = null;
    let highestScore = 0;

    for (const project of projectsToSearch) {
        let score = 0;
        const projectText = `${project.name} ${project.description} ${project.tags.join(' ')}`.toLowerCase();

        for (const word of queryWords) {
            if (projectText.includes(word)) {
                score++;
            }
        }
        
        // Boost score for direct tag matches
        for (const tag of project.tags) {
            if (query.toLowerCase().includes(tag.toLowerCase())) {
                score += 2; // Give more weight to tags
            }
        }

        if (score > highestScore) {
            highestScore = score;
            bestMatch = project;
        }
    }

    // Only return a match if there's at least one keyword hit
    return highestScore > 0 ? bestMatch : null;
}

/**
 * Renders project cards into the projects container by fetching data from the tool.
 */
async function renderProjects() {
  if (!projectsContainer) return;
  const { projects: projectsFromTool } = await projectMetadataTool();
  projectsContainer.innerHTML = projectsFromTool
    .map(
      (project) => `
    <a href="${project.url}" target="_blank" rel="noopener noreferrer" class="project-card-link">
        <div class="project-card">
        <h3>${project.name}</h3>
        <p>${project.description}</p>
        <div class="project-tags">
            ${project.tags.map((tag) => `<span class="tag">${tag}</span>`).join("")}
        </div>
        </div>
    </a>
  `,
    )
    .join("");
}

// --- Theme Toggling ---
/**
 * Sets the color theme for the application.
 * @param {'light' | 'dark'} theme - The theme to set.
 */
function setTheme(theme: 'light' | 'dark') {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
    if (themeToggleBtn) {
        themeToggleBtn.innerHTML = theme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        themeToggleBtn.setAttribute('aria-label', `Switch to ${theme === 'dark' ? 'light' : 'dark'} mode`);
    }
}

/**
 * Handles the click event for the theme toggle button.
 */
function handleThemeToggle() {
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    setTheme(newTheme as 'light' | 'dark');
}

// --- Event Listeners ---
themeToggleBtn?.addEventListener('click', handleThemeToggle);

// --- Initialization ---
document.addEventListener("DOMContentLoaded", async () => {
  await renderProjects();
  
  // Initialize the chatbot, passing in the necessary data and functions
  initializeChatbot(projects, projectMetadataTool, findBestProjectMatchByKeywords);
  
  // Set initial theme based on localStorage or user preference
  const initialTheme = document.documentElement.getAttribute('data-theme');
  if (initialTheme === 'light' || initialTheme === 'dark') {
      setTheme(initialTheme as 'light' | 'dark');
  }
});